"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const index_1 = require("../index");
let connection;
const credentials = {
    host: 'localhost',
    user: 'test',
    password: 'test',
    database: 'test',
    multipleStatements: true
};
const testMe = [
    ['Connect', () => {
            it('should connect', () => __awaiter(void 0, void 0, void 0, function* () {
                connection = yield index_1.mysql21.createConnection(credentials);
                chai_1.expect(connection.constructor.name).to.equal('PromiseConnection');
            }));
            it('should not be closed', () => chai_1.expect(connection.connection._paused).to.equal(false));
        }],
    ['Discconnect', () => {
            it('should disconnect', () => chai_1.expect(() => __awaiter(void 0, void 0, void 0, function* () { return yield connection.end(); })).not.to.throw());
        }],
    ['Connect with Pool', () => {
            it('should connect pool', () => __awaiter(void 0, void 0, void 0, function* () {
                connection = yield index_1.mysql21.createPool(credentials);
                chai_1.expect(connection.constructor.name).to.equal('PromisePool');
            }));
            it('pool should not be closed', () => chai_1.expect(connection.pool._closed).to.equal(false));
        }],
    ['Write some test data', () => {
            it('should drop table if exists', () => __awaiter(void 0, void 0, void 0, function* () {
                let query = yield connection.query(`DROP TABLE IF EXISTS listings;`);
                chai_1.expect(query.constructor.name).to.equal('ResultSetHeader');
            }));
            it('should create table', () => __awaiter(void 0, void 0, void 0, function* () {
                let query = yield connection.query(`
  CREATE TABLE listings (
  id INT NOT NULL AUTO_INCREMENT PRIMARY KEY,
  data JSON NOT NULL
  )`);
                chai_1.expect(query.constructor.name).to.equal('ResultSetHeader');
            }));
            it('should insert', () => __awaiter(void 0, void 0, void 0, function* () {
                let query = yield connection.query(`
  INSERT INTO listings (data) VALUES
  ('{
  "title": "First Listing",
  "public": false,
  "text": "Lorem ipsum",
  "address": "Klimentská 1215/25, 110 00, Prague 1"
  }'),
  ('{
  "title": "Second Listing",
  "public": true,
  "text": "Dolor sit amet",
  "address": "Rybná 716/24, 110 00, Prague 1"
  }'),
  ('{
  "title": "Third Listing",
  "public": true,
  "text": "Consectetur adipiscing elit",
  "address": "Jagellonská 1, 130 00, Prague 3"
  }');`);
                chai_1.expect(query.constructor.name).to.equal('ResultSetHeader');
                chai_1.expect(query.insertId).to.be.an('number');
            }));
        }],
    ['Read some data', () => {
            let read;
            it('should be an array', () => __awaiter(void 0, void 0, void 0, function* () {
                read = yield connection.query('SELECT * FROM listings;');
                chai_1.expect(Array.isArray(read)).to.be.true;
            }));
            it('should be 3', () => chai_1.expect(read.length).to.equal(3));
            it('data should be JSON', () => chai_1.expect(read.every(r => typeof r.data === 'object')).to.be.true);
            it('data should not contain `timestamp`', () => chai_1.expect(read[0]).to.not.have.property('timestamp'));
        }],
    ['Fail something', () => {
            let err;
            it('should catch', () => __awaiter(void 0, void 0, void 0, function* () {
                err = yield connection.query('SELECT * FROM listings WHERE nofield = ?;', [-1]).catch(e => e);
                chai_1.expect(err.constructor.name).to.equal('Error');
            }));
            it('should be ER_BAD_FIELD_ERROR', () => chai_1.expect(err.code).to.equal('ER_BAD_FIELD_ERROR'));
            it('should include formated SQL', () => chai_1.expect(typeof err.sql).to.equal('string'));
        }],
    ['Read single value', () => {
            it('should be an array', () => __awaiter(void 0, void 0, void 0, function* () {
                let read = yield connection.single('SELECT COUNT(*) FROM listings;');
                chai_1.expect(read).to.equal(3);
            }));
        }],
    ['Read as an object', () => {
            let read;
            it('should be an object, not an array', () => __awaiter(void 0, void 0, void 0, function* () {
                read = yield connection.assoc('id', 'SELECT * FROM listings;');
                chai_1.expect(typeof read === 'object' && !Array.isArray(read)).to.be.true;
            }));
            it("'should contain key '1'", () => chai_1.expect(read['1']).to.be.an('object'));
            it('should contain original row values', () => chai_1.expect(read['1']).to.have.own.property('id'));
            it('should not contain data column directly', () => chai_1.expect(read['1']).to.not.have.own.property('title'));
        }],
    ['Read in pairs as an object', () => {
            let read;
            it('should be an object, not an array', () => __awaiter(void 0, void 0, void 0, function* () {
                read = yield connection.pairs('id', 'data', 'SELECT * FROM listings;');
                chai_1.expect(typeof read === 'object' && !Array.isArray(read)).to.be.true;
            }));
            it("'should contain key '1'", () => chai_1.expect(read['1']).to.be.an('object'));
            it('should not contain original row values', () => chai_1.expect(read['1']).to.not.have.own.property('id'));
            it('should contain data column directly', () => chai_1.expect(read['1']).to.have.own.property('title'));
        }],
    ['Drop table', () => it("drop listings", () => chai_1.expect(() => __awaiter(void 0, void 0, void 0, function* () { return yield connection.query("DROP TABLE listings"); })).not.to.throw())],
    ['???', () => it('is unknown', () => chai_1.expect(undefined).to.be.undefined)],
    ['end connection with PROFIT', () => it('at least you have hope', () => chai_1.expect(() => __awaiter(void 0, void 0, void 0, function* () { return yield connection.end(); })).not.to.throw())]
];
testMe.forEach(([title, test], i) => {
    describe(`${i - 1}. ${title}`, test);
});
//# sourceMappingURL=test.js.map